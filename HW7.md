## HW7
## Cory Yelverton

1. I think testing should occur at all phases of software development past the design phase. During development automated testing should be ran alongside new code. Dedicated testers should have a phase to test it just for the sake of being impartial. As long as things going out on time you can't over test.
2. The similarities between verification and validation start by both being in quality assurance. They are both focused towards delivering quality. Verification is concerned with process and is done after each workflow. Validation is product centric and happens once before work goes to the client.
3. Non-Execution testing does not use test cases and instead reads through software or by math. Execution based testing uses test cases.
4.  I agree with the book in that the minimum of quality is how much it satisfies specifications. However, the code should be delivered in such a way that changes are as effortless as possible, secure, and expandable to the client over time.
5. The same reason why you don't put your own grades on a report card. The same reason the sales team doesn't do the accounting. If you have a reason to lie, in this case the metric of your reputation, then you shouldn't do it.
6. Correctness proof is a mathematical technique while execution based testing runs test cases to see the input. I think the latter is better because you can mimic real world scenarios easier. Secondly, it is likely easier to adopt to a testing team than correctness proof.
7. I think the article highlights an interesting point with the idea software is replacing manual processes. It highlights the need for good software development and even better testing to ensure it doesn't put life at danger. However, I wonder if a culprit of these problems is the fact programmers are so detached from the reality of what they create. You are just  concerned with specifications on paper, and you program what you are told and move on. I'm curious to see if the best software is created at large companies or small companies for this purpose. The article talks a little bit about this later on. Smaller companies likely have less middlemen between the client and the programmer. I'm also shocked that Visual Studio is so bloated. The first time I used it felt like a life changing experience.
8. I see my role as someone who has a strong internal scoreboard. To be honest with you I don't see a path to me ever being a good programmer. I manage in my classes okay. The programming assignments are usually the easiest parts of the class, but I'm not geared for it. It isn't much natural place. I'm more concerned with the challenge that comes with people and process. I think that leads me into never losing sight of the other end of what code becomes. I don't see the beginning and end being specifications on a page. If by some chance I luck up and become a programmer I want to work for a company that prides itself on the end user feeling good about the product, and not a group of managers happy that the check cleared. I'm curious and passionate about the program to solve and use many hours reflecting on how something I've experienced is more than meets the eye. I do not think there will be a software apocalypse. We are in a fairly new phase of software and with anything that comes some learning pains. I believe in the market and the human spirit to improve what we have now. 
