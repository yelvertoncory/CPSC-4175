## HW 6
## Cory Yelverton

1. The two problem domains are applications for mainframe products at TSYS and distributed products. Mainframe COBOL works better than JAVA mainly because that is what the traditional choice of language is, and you are adding onto existing code so it is hard to blend Java and COBOL. Java works for distributed products because the client side will likely recognize it, and internally you have likely used it enough to develop classes/knowledge bases you can reuse.
2.  An example I've actually been involved in is calling RTCData r and RTCDataLinks d in several 100 lines of SQL code. For non self-documenting code you could have a global variable named num, which isn't descriptive and without comments you can't infer a definition. As far as code layout having all your selects on one line is SQL is ugly to read.(Select id, name, a, b , c , d , e , f , g from table)
3.
4. So during my internship a lot of the metrics we made involved getting different environment dates for a particular release/iteration. These are in two separate tables, and it includes creating variables based on the date for production(productionDate - 21 AS DevDate, etc). Someone in my team made a method that does all that if you pass it the release date.
5. A stub is an empty artifact. A driver is a code artifact that calls it one or more times. //boolean cost(double unitPrice, double salesTax, int Quantity){unitprice = 1, print("Unit price successful", unitPrice)}
6.  Strengths : easy to identify error locations, errors show up early. Weakness : Miss potentially reusable coding artifacts.
7. Strengths : fault isolation, aid of drivers. Weakness: Design flaws detected late.
8. Sandwich integration in the book is the interfaces between the bottom-up and top-down groups are tested one by one. A DSL would work in this regard because in order for a DSL to work it has to be placed in the center. What is great is you can test each artifact with your DSL to locate the problem, and if that artifact is dependent on other, like in bottom-up, you can locate the trail of the issue.
9. Testing during development is trying to "destroy your creation." Also, a developer can test against his/her interpretation of the requirements, but maybe not the actual requirements. Testing in SQA is independent of the pressures a development team would have, and is hopefully more accurate.
10. Let me start by saying that the topic of the essay, go to statements, I have never been taught so that is likely a positive for you. His writing style is pretty dense so it hard to get through, but I think I remember this guy in discrete math. I agree with the logic that go to statements allow you to get around writing good code. This is the result of losing the ability to see "process progress" as he refers to it in the article.
