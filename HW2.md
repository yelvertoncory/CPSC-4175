##Homework 2

1.The first step in creating software is requirements analysis
2.This is actually a good question. One of the things TSYS was battling with this summer was the idea of a product driven vs client driven software. On a large scale client driven software changes
are more adhoc changes, and you have to manage versions of the software for each client. This is the way TSYS operates and it stretches resources thin. Product driven revolves around determining what changes to 
make first by seeing how many of your clients give it priority. After "grooming the backlog" you can make the change at once instead of just getting a change from someone and making it. The friction point comes 
when a client request a change that you give low priority and they keep asking you about it. What you should do is ask for a contract and money to just speed up that change, but it is a juggling act. I've seen it in my 
own small reporting team while I was there. We essentially managed metrics/reports for the product division of IT and at the time we made changes to a report that a single group requested. If a team requested a new report
they would just do it instead of grooming it to determine the priority. 
3. The bigger the company the more specialized you can be, but even at a large company a software engineer needs to understand various technologies, proccesses, client expectations, and the dreaded meetings/emails. In a way you have to develop
a toolkit to use when they requirements call for it.
4. Business Model - The weakness here is the software developer is more of a consultant; spending more time learning about the business rather than developing software. Interviewing - The weakness here is you are too prescriptive. It is good to train the user to look for opportunities to automate.
5. Requirements are dynamic because you should expect them to change and reflect this in your attitude.. Some may stay close to their original draft, but many will change all together. Once the client sees the software there may very well be new requirements introduced.
6. Functional requirements are what the software does. Non-Functional requirements is what the software feels like(response time, font, etc). You can have all the functional requirements complete with the most modest of the non functional and have working software. 
Font type and size is an example of a true non-functional requirement. The only exception to this is if you use bright yellow comic sans font on a web page for a client. Sure, the page may work, but it wil have a negative impact to the company's reputation.
7. Top-Down Analysis is trying to determine what the software does as a whole and working backwards to break it into separate parts. The case study in the book starts out with just focusing on the mortgage function and developers from there.
8. Prototyping is very prescriptive. This is dangerous to the culture of the software team and the client.  If software developers are just creating software to look like a prototype it is easy to miss the critical thinking part of development. If a client only has to approve a prototype it doesn't
force them to think for themselves. The other phase of it is if you go from initial meeting > changes > new prototype draft > changes > new prototype draft you can easily fall victim to lack of progress. 
9. I could go either way here, but we have to operate off assumptions for me to say team two is better off. If they have a very strong presence in feedback to the client to get more requirements/changes then kudos to them. If they simply did a poor job initially or they are allowing the customer
to dictate too much change then that isn't good as well. As a rule of thumb though I think constant changes show at least communication with the client. In an agile world this is okay.
10. I would say if you consider a defect as "this doesn't do what I expected it to do" then that solely belongs in the realm of missing the mark with requirements. When you are internally testing against the requirements than a pass means it does what you think it should do, but that doesn't mean it does
what the client should do. So there is no way for the team internally to determine this mismatch without changing the requirements beforehand.

